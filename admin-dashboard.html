<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resume Writer - Admin Dashboard</title>
    <style>
        /* [Keep all CSS styles exactly as before] */
    </style>
</head>
<body>
    <!-- [Keep all HTML exactly as before] -->
    
    <!-- Error Tracking Section -->
    <div class="section-card">
        <h3 class="section-title">
            üö® Error Tracking & Monitoring
            <span id="streamIndicator" class="badge" style="background: #dc2626;">OFFLINE</span>
        </h3>
        
        <!-- Stream Controls -->
        <div class="stream-controls">
            <div class="stream-status">
                <div class="status-dot" id="streamStatusDot"></div>
                <span id="streamStatusText">Real-time error stream: Disconnected</span>
            </div>
            <div style="display: flex; gap: 8px;">
                <button class="btn btn-success btn-small" onclick="startErrorStream()" id="startStreamBtn">
                    ‚ñ∂ Start Stream
                </button>
                <button class="btn btn-danger btn-small" onclick="stopErrorStream()" id="stopStreamBtn" style="display: none;">
                    ‚èπ Stop Stream
                </button>
                <button class="btn btn-warning btn-small" onclick="loadAllErrors()" id="loadErrorsBtn">
                    üîÑ Refresh Errors
                </button>
                <button class="btn btn-danger btn-small" onclick="clearOldErrors()">
                    üóëÔ∏è Clear Old
                </button>
            </div>
        </div>
        
        <!-- Filter Controls -->
        <div class="filter-controls">
            <div class="filter-group">
                <label>Search User ID</label>
                <input type="text" id="errorUserIdFilter" class="filter-input" placeholder="Filter by User ID" 
                       onkeyup="filterErrors()">
            </div>
            <div class="filter-group">
                <label>Search Endpoint</label>
                <input type="text" id="errorEndpointFilter" class="filter-input" placeholder="Filter by endpoint" 
                       onkeyup="filterErrors()">
            </div>
            <div class="filter-group">
                <label>Severity</label>
                <select id="errorSeverityFilter" class="filter-select" onchange="filterErrors()">
                    <option value="all">All Severities</option>
                    <option value="high">High</option>
                    <option value="medium">Medium</option>
                    <option value="low">Low</option>
                </select>
            </div>
            <div class="filter-group">
                <label>Time Range</label>
                <select id="errorTimeFilter" class="filter-select" onchange="filterErrors()">
                    <option value="7">Last 7 Days</option>
                    <option value="1">Today</option>
                    <option value="30">Last 30 Days</option>
                    <option value="all">All Time</option>
                </select>
            </div>
        </div>
        
        <!-- Error Summary -->
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 16px; margin-bottom: 20px;">
            <div style="background: #0f172a; padding: 16px; border-radius: 8px; border: 1px solid #334155; text-align: center;">
                <div style="font-size: 1.5rem; font-weight: 700; color: #e2e8f0;" id="errorTotalCount">0</div>
                <div style="color: #94a3b8; font-size: 0.85rem;">Total Errors</div>
            </div>
            <div style="background: #7f1d1d; padding: 16px; border-radius: 8px; text-align: center;">
                <div style="font-size: 1.5rem; font-weight: 700; color: #fecaca;" id="errorHighCount">0</div>
                <div style="color: #fecaca; font-size: 0.85rem;">High Severity</div>
            </div>
            <div style="background: #0f172a; padding: 16px; border-radius: 8px; border: 1px solid #334155; text-align: center;">
                <div style="font-size: 1.5rem; font-weight: 700; color: #e2e8f0;" id="errorUserCount">0</div>
                <div style="color: #94a3b8; font-size: 0.85rem;">Affected Users</div>
            </div>
            <div style="background: #0f172a; padding: 16px; border-radius: 8px; border: 1px solid #334155; text-align: center;">
                <div style="font-size: 1.5rem; font-weight: 700; color: #e2e8f0;" id="errorEndpointCount">0</div>
                <div style="color: #94a3b8; font-size: 0.85rem;">Endpoints</div>
            </div>
        </div>
        
        <!-- Error List Container - This stays exactly as your original -->
        <div id="errorListContainer">
            <div id="errorList" style="min-height: 200px;">
                <div style="text-align: center; padding: 40px; color: #94a3b8;">
                    <div style="font-size: 3rem; margin-bottom: 16px;">üìä</div>
                    <h3 style="margin-bottom: 8px; color: #e2e8f0;">No Errors Found</h3>
                    <p>Errors will appear here when they occur. Start the error stream to monitor in real-time.</p>
                    <button class="btn btn-success" onclick="startErrorStream()" style="margin-top: 20px;">
                        ‚ñ∂ Start Real-time Monitoring
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- [Keep the rest of your HTML exactly as before] -->

    <script>
        // Configuration - Match your server endpoints
        const API_BASE_URL = window.location.origin === 'http://localhost:3000' 
            ? 'http://localhost:8000' 
            : 'https://resume-writer-api.onrender.com';
        
        // State management
        let currentSession = null;
        let refreshInterval = null;
        let sessionTimerInterval = null;
        let sessionStartTime = null;
        let autoRefreshEnabled = true;
        
        // Error tracking state
        let errorEventSource = null;
        let currentErrorData = [];
        let isStreaming = false;
        
        // UI State
        let isRefreshing = false;

        // Initialize when DOM loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ Admin Dashboard Initializing...');
            
            // Load persistent errors from localStorage
            loadErrorsFromStorage();
            
            // Auto-login with stored UID or default
            const storedUID = localStorage.getItem('admin_uid') || ADMIN_UID;
            document.getElementById('firebaseUID').value = storedUID;
            
            // Start auto-login process
            setTimeout(() => {
                attemptAutoLogin();
            }, 1000);
        });

        // ========== PERSISTENT ERROR STORAGE ==========

        function loadErrorsFromStorage() {
            try {
                const storedErrors = localStorage.getItem('admin_dashboard_errors');
                if (storedErrors) {
                    currentErrorData = JSON.parse(storedErrors);
                    console.log(`üìä Loaded ${currentErrorData.length} errors from persistent storage`);
                    
                    // Update UI with stored errors
                    updateErrorSummary(currentErrorData);
                    
                    // Only display if there are errors
                    if (currentErrorData.length > 0) {
                        displayErrors(currentErrorData);
                    }
                    
                    return currentErrorData;
                }
            } catch (error) {
                console.error('‚ùå Failed to load errors from storage:', error);
            }
            return [];
        }

        function saveErrorsToStorage() {
            try {
                // Limit stored errors to prevent localStorage overflow
                const errorsToSave = currentErrorData.slice(0, 1000);
                localStorage.setItem('admin_dashboard_errors', JSON.stringify(errorsToSave));
                console.log(`üíæ Saved ${errorsToSave.length} errors to persistent storage`);
            } catch (error) {
                console.error('‚ùå Failed to save errors to storage:', error);
            }
        }

        // ========== AUTHENTICATION ==========

        function attemptAutoLogin() {
            const firebaseUID = document.getElementById('firebaseUID').value.trim();
            console.log('üîê Attempting auto-login with UID:', firebaseUID);
            
            if (!firebaseUID) {
                showLoginScreen();
                return;
            }
            
            showAutoLoginStatus('üîÑ Testing authentication...');
            
            // First check if server is reachable
            fetch(`${API_BASE_URL}/health`)
                .then(response => {
                    if (!response.ok) throw new Error('Server not reachable');
                    return loginWithUID(firebaseUID);
                })
                .catch(error => {
                    console.error('Server check failed:', error);
                    showAutoLoginStatus('‚ùå Server not reachable');
                    setTimeout(showLoginScreen, 2000);
                });
        }

        async function loginWithUID(firebaseUID) {
            try {
                showAutoLoginStatus('üîë Verifying admin privileges...');
                
                // Try to access admin endpoints
                const response = await fetch(`${API_BASE_URL}/admin/errors/stats`, {
                    headers: {
                        'X-User-ID': firebaseUID,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    // Success! User has admin privileges
                    currentSession = {
                        uid: firebaseUID,
                        type: 'firebase',
                        timestamp: new Date().toISOString()
                    };
                    
                    // Store UID for future sessions
                    localStorage.setItem('admin_uid', firebaseUID);
                    
                    showAutoLoginStatus('‚úÖ Authentication successful!');
                    
                    setTimeout(() => {
                        handleSuccessfulLogin();
                    }, 1000);
                    
                } else if (response.status === 403) {
                    // Admin access denied
                    throw new Error('Admin privileges required');
                } else {
                    // Other error
                    throw new Error(`Server returned ${response.status}`);
                }
                
            } catch (error) {
                console.error('Login error:', error);
                showAutoLoginStatus(`‚ùå ${error.message}`);
                
                setTimeout(() => {
                    showLoginScreen();
                }, 3000);
            }
        }

        function showAutoLoginStatus(message) {
            const statusElement = document.getElementById('autoLoginStatus');
            if (statusElement) {
                const icon = message.includes('‚úÖ') ? '‚úÖ' : 
                            message.includes('‚ùå') ? '‚ùå' : 
                            message.includes('üîë') ? 'üîë' : 'üîÑ';
                
                statusElement.innerHTML = `
                    <div style="
                        background: rgba(255,255,255,0.1); 
                        padding: 16px; 
                        border-radius: 8px; 
                        border: 1px solid #334155;
                        font-family: monospace;
                        font-size: 0.9rem;
                        color: ${message.includes('‚ùå') ? '#f87171' : '#e2e8f0'};
                    ">
                        ${icon} ${message}
                    </div>
                `;
            }
        }

        function showLoginScreen() {
            console.log('üì± Showing login screen');
            document.getElementById('autoLoginOverlay').style.display = 'none';
            document.getElementById('loginScreen').style.display = 'block';
            document.getElementById('dashboard').style.display = 'none';
        }

        async function login() {
            const firebaseUID = document.getElementById('firebaseUID').value.trim();
            
            if (!firebaseUID) {
                showLoginMessage('Please enter Firebase UID', 'error');
                return;
            }
            
            showLoginMessage('üîÑ Testing authentication...', 'info');
            
            try {
                await loginWithUID(firebaseUID);
            } catch (error) {
                console.error('Login error:', error);
                showLoginMessage('‚ùå Login failed: ' + error.message, 'error');
            }
        }

        function showLoginMessage(message, type) {
            const messageDiv = document.getElementById('loginMessage');
            if (messageDiv) {
                messageDiv.innerHTML = `
                    <div style="
                        padding: 12px; 
                        border-radius: 8px; 
                        border-left: 4px solid ${type === 'error' ? '#ef4444' : type === 'success' ? '#10b981' : '#3b82f6'};
                        background: #0f172a;
                        color: #e2e8f0;
                    ">
                        ${message}
                    </div>
                `;
                messageDiv.style.display = 'block';
                
                setTimeout(() => {
                    messageDiv.style.display = 'none';
                }, 5000);
            }
        }

        function handleSuccessfulLogin() {
            console.log('üéâ Login successful, showing dashboard');
            
            // Hide login screens
            document.getElementById('autoLoginOverlay').style.display = 'none';
            document.getElementById('loginScreen').style.display = 'none';
            
            // Show dashboard
            document.getElementById('dashboard').style.display = 'block';
            
            // Initialize dashboard
            sessionStartTime = new Date();
            document.getElementById('adminUID').textContent = currentSession.uid;
            
            showMessage('‚úÖ Authentication successful! Dashboard loaded.', 'success');
            
            // Load initial data
            refreshStats();
            startAutoRefresh();
            startSessionTimer();
            
            // Initialize error tracking
            initializeErrorTracking();
        }

        // ========== ERROR TRACKING ==========

        function initializeErrorTracking() {
            if (!currentSession) return;
            
            // Load fresh errors from server
            loadAllErrors();
            
            // Auto-start stream
            startErrorStream();
        }

        async function loadAllErrors(days = 7, limit = 200) {
            console.log(`üì• Loading errors for last ${days} days...`);
            
            if (!currentSession) {
                console.log('‚ö†Ô∏è Not logged in, using stored errors only');
                // Already showing stored errors from loadErrorsFromStorage()
                return;
            }

            try {
                const response = await fetch(
                    `${API_BASE_URL}/admin/errors/historical?days=${days}&limit=${limit}`,
                    {
                        headers: {
                            'X-User-ID': currentSession.uid,
                            'Content-Type': 'application/json'
                        }
                    }
                );

                if (response.status === 403) {
                    throw new Error('Admin privileges required');
                }

                if (!response.ok) {
                    throw new Error(`Failed to load errors: ${response.status}`);
                }

                const data = await response.json();
                const newErrors = data.success ? data.errors : [];
                
                console.log(`üìä Received ${newErrors.length} new errors from server`);
                
                // Merge new errors with existing ones
                mergeErrors(newErrors);
                
            } catch (error) {
                console.error('‚ùå Error loading from server:', error);
                showMessage('‚ö†Ô∏è Using cached errors. Could not fetch new ones: ' + error.message, 'warning');
            }
        }

        function mergeErrors(newErrors) {
            if (!newErrors || newErrors.length === 0) return;
            
            // Create a map of error IDs for quick lookup
            const errorMap = new Map();
            
            // First add all existing errors
            currentErrorData.forEach(error => {
                if (error.id) {
                    errorMap.set(error.id, error);
                }
            });
            
            // Add or update with new errors
            newErrors.forEach(error => {
                if (error.id) {
                    // Update existing or add new
                    errorMap.set(error.id, error);
                } else {
                    // Generate ID for errors without one
                    const generatedId = `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    error.id = generatedId;
                    errorMap.set(generatedId, error);
                }
            });
            
            // Convert back to array and sort by timestamp (newest first)
            currentErrorData = Array.from(errorMap.values())
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                .slice(0, 500);
            
            // Save to persistent storage
            saveErrorsToStorage();
            
            // Update UI
            updateErrorSummary(currentErrorData);
            displayErrors(currentErrorData);
            
            console.log(`‚úÖ Merged errors. Total: ${currentErrorData.length}`);
        }

        function updateErrorSummary(errors) {
            if (!errors || !Array.isArray(errors)) return;
            
            const total = errors.length;
            const high = errors.filter(e => e.severity === 'high').length;
            const users = [...new Set(errors.map(e => e.user_id))].length;
            const endpoints = [...new Set(errors.map(e => e.endpoint))].length;
            const today = new Date().toDateString();
            const errorCountToday = errors.filter(e => 
                new Date(e.timestamp).toDateString() === today
            ).length;
            
            document.getElementById('errorTotalCount').textContent = total;
            document.getElementById('errorHighCount').textContent = high;
            document.getElementById('errorUserCount').textContent = users;
            document.getElementById('errorEndpointCount').textContent = endpoints;
            
            // Update main stats
            document.getElementById('totalErrors').textContent = total;
            document.getElementById('highErrors').textContent = high;
            document.getElementById('errorCountToday').textContent = errorCountToday;
        }

        function displayErrors(errors) {
            const container = document.getElementById('errorList');
            
            if (!errors || errors.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #94a3b8;">
                        <div style="font-size: 3rem; margin-bottom: 16px;">üìä</div>
                        <h3 style="margin-bottom: 8px; color: #e2e8f0;">No Errors Found</h3>
                        <p>Errors will appear here when they occur. Start the error stream to monitor in real-time.</p>
                        <button class="btn btn-success" onclick="startErrorStream()" style="margin-top: 20px;">
                            ‚ñ∂ Start Real-time Monitoring
                        </button>
                    </div>
                `;
                return;
            }

            let html = `
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Timestamp</th>
                            <th>User ID</th>
                            <th>Endpoint</th>
                            <th>Type</th>
                            <th>Severity</th>
                            <th>Message</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            errors.forEach(error => {
                const timestamp = new Date(error.timestamp).toLocaleString();
                const shortUserId = error.user_id?.substring(0, 12) + '...' || 'unknown';
                const shortMessage = error.error_message?.substring(0, 60) + 
                                   (error.error_message?.length > 60 ? '...' : '');
                
                const severity = error.severity?.toLowerCase() || 'info';
                const severityClass = `severity-${severity}`;
                const severityText = severity.charAt(0).toUpperCase() + severity.slice(1);
                
                html += `
                    <tr>
                        <td style="font-family: monospace; font-size: 0.85rem; color: #94a3b8;">
                            ${timestamp}
                        </td>
                        <td>
                            <div class="tooltip">
                                <span style="font-family: monospace; color: #60a5fa;">${shortUserId}</span>
                                <span class="tooltip-text">${error.user_id || 'No user ID'}</span>
                            </div>
                        </td>
                        <td style="color: #a78bfa;">${error.endpoint || 'Unknown'}</td>
                        <td style="color: #cbd5e1;">${error.error_type || 'Unknown'}</td>
                        <td>
                            <span class="severity-badge ${severityClass}">${severityText}</span>
                        </td>
                        <td style="max-width: 300px; word-break: break-word;">${shortMessage}</td>
                        <td>
                            <button class="btn btn-small" 
                                    onclick="showErrorDetails('${error.id || 'unknown'}')"
                                    style="background: #334155; padding: 4px 8px; font-size: 12px;">
                                üîç View
                            </button>
                        </td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function filterErrors() {
            if (!currentErrorData || currentErrorData.length === 0) return;
            
            const userId = document.getElementById('errorUserIdFilter').value.toLowerCase();
            const endpoint = document.getElementById('errorEndpointFilter').value.toLowerCase();
            const severity = document.getElementById('errorSeverityFilter').value;
            const timeRange = document.getElementById('errorTimeFilter').value;

            let filtered = [...currentErrorData];
            
            // Apply filters
            if (userId) {
                filtered = filtered.filter(error => 
                    error.user_id?.toLowerCase().includes(userId)
                );
            }
            
            if (endpoint) {
                filtered = filtered.filter(error => 
                    error.endpoint?.toLowerCase().includes(endpoint)
                );
            }
            
            if (severity !== 'all') {
                filtered = filtered.filter(error => 
                    error.severity?.toLowerCase() === severity
                );
            }
            
            // Apply time filter
            if (timeRange !== 'all') {
                const days = parseInt(timeRange);
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - days);
                
                filtered = filtered.filter(error => 
                    new Date(error.timestamp) >= cutoffDate
                );
            }
            
            displayErrors(filtered);
            updateErrorSummary(filtered);
        }

        function startErrorStream() {
            if (!currentSession || isStreaming) return;
            
            try {
                const streamUrl = `${API_BASE_URL}/admin/errors/stream?uid=${encodeURIComponent(currentSession.uid)}`;
                errorEventSource = new EventSource(streamUrl);
                
                errorEventSource.onopen = () => {
                    console.log('‚úÖ Error stream connected');
                    isStreaming = true;
                    updateStreamStatus(true);
                    showMessage('‚úÖ Connected to real-time error stream', 'success');
                };
                
                errorEventSource.onmessage = (event) => {
                    if (event.data.startsWith(':')) return; // Skip keep-alive
                    
                    try {
                        const data = JSON.parse(event.data);
                        handleStreamMessage(data);
                    } catch (e) {
                        // Non-JSON message or parse error
                        console.log('üì¶ Stream message:', event.data);
                    }
                };
                
                errorEventSource.onerror = (error) => {
                    console.error('‚ùå Error stream disconnected:', error);
                    isStreaming = false;
                    updateStreamStatus(false);
                    
                    // Try to reconnect after delay
                    setTimeout(() => {
                        if (!isStreaming && currentSession) {
                            console.log('üîÑ Reconnecting error stream...');
                            startErrorStream();
                        }
                    }, 5000);
                };
                
            } catch (error) {
                console.error('‚ùå Failed to start error stream:', error);
                showMessage('Failed to start error stream', 'error');
            }
        }

        function handleStreamMessage(data) {
            switch(data.type) {
                case 'connected':
                    console.log('üîó ' + data.message);
                    break;
                    
                case 'new_error':
                    // Create error object
                    const error = {
                        id: data.id || `stream_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        timestamp: data.timestamp || new Date().toISOString(),
                        user_id: data.user_id || data.userId || 'unknown',
                        endpoint: data.endpoint || 'unknown',
                        error_type: data.error_type || data.errorType || 'unknown',
                        severity: data.severity || 'info',
                        error_message: data.message || data.error_message || 'No message',
                        extra_data: data.extra_data || data.details || null
                    };
                    
                    // Add to beginning of array
                    currentErrorData.unshift(error);
                    
                    // Limit to 500 errors
                    if (currentErrorData.length > 500) {
                        currentErrorData = currentErrorData.slice(0, 500);
                    }
                    
                    // Save to persistent storage
                    saveErrorsToStorage();
                    
                    // Update UI
                    updateErrorSummary(currentErrorData);
                    
                    // Update display
                    updateErrorTableWithNewRow(error);
                    
                    // Show notification
                    showErrorNotification(error);
                    break;
                    
                case 'stream_error':
                    console.warn('‚ö†Ô∏è Stream error:', data.message);
                    break;
                    
                case 'stream_closed':
                    console.log('üîí Stream closed');
                    isStreaming = false;
                    updateStreamStatus(false);
                    break;
            }
        }

        function updateErrorTableWithNewRow(error) {
            const container = document.getElementById('errorList');
            const currentContent = container.innerHTML;
            
            // If we're showing the "no errors" message, replace it with table
            if (currentContent.includes('No Errors Found')) {
                displayErrors([error]);
            } else {
                // Find the table body and insert new row
                const table = container.querySelector('tbody');
                if (table) {
                    const row = createErrorTableRow(error);
                    table.insertAdjacentHTML('afterbegin', row);
                    
                    // Limit table size
                    if (table.children.length > 100) {
                        table.lastElementChild.remove();
                    }
                } else {
                    // If no table found, reload all errors
                    displayErrors(currentErrorData);
                }
            }
        }

        function createErrorTableRow(error) {
            const timestamp = new Date(error.timestamp).toLocaleString();
            const shortUserId = error.user_id?.substring(0, 12) + '...' || 'unknown';
            const shortMessage = error.error_message?.substring(0, 60) + 
                               (error.error_message?.length > 60 ? '...' : '');
            
            const severity = error.severity?.toLowerCase() || 'info';
            const severityClass = `severity-${severity}`;
            const severityText = severity.charAt(0).toUpperCase() + severity.slice(1);
            
            return `
                <tr>
                    <td style="font-family: monospace; font-size: 0.85rem; color: #94a3b8;">
                        ${timestamp}
                    </td>
                    <td>
                        <div class="tooltip">
                            <span style="font-family: monospace; color: #60a5fa;">${shortUserId}</span>
                            <span class="tooltip-text">${error.user_id || 'No user ID'}</span>
                        </div>
                    </td>
                    <td style="color: #a78bfa;">${error.endpoint || 'Unknown'}</td>
                    <td style="color: #cbd5e1;">${error.error_type || 'Unknown'}</td>
                    <td>
                        <span class="severity-badge ${severityClass}">${severityText}</span>
                    </td>
                    <td style="max-width: 300px; word-break: break-word;">${shortMessage}</td>
                    <td>
                        <button class="btn btn-small" 
                                onclick="showErrorDetails('${error.id}')"
                                style="background: #334155; padding: 4px 8px; font-size: 12px;">
                            üîç View
                        </button>
                    </td>
                </tr>
            `;
        }

        function showErrorNotification(error) {
            const severity = error.severity?.toLowerCase() || 'info';
            const title = `üö® New ${severity} error`;
            
            const notification = document.createElement('div');
            notification.className = `message message-${severity === 'high' ? 'error' : 'warning'}`;
            notification.innerHTML = `
                <strong>${title}</strong><br>
                ${error.error_type} on ${error.endpoint}<br>
                <small style="color: #94a3b8;">User: ${error.user_id?.substring(0, 15)}...</small>
                <button onclick="this.parentElement.remove()" 
                        style="float: right; background: none; border: none; color: #94a3b8; cursor: pointer; font-size: 18px;">
                    √ó
                </button>
            `;
            
            const container = document.getElementById('messageContainer');
            if (container) {
                container.appendChild(notification);
                
                // Auto-remove after 8 seconds
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.remove();
                    }
                }, 8000);
            }
        }

        function stopErrorStream() {
            if (errorEventSource) {
                errorEventSource.close();
                errorEventSource = null;
            }
            
            isStreaming = false;
            updateStreamStatus(false);
            showMessage('‚èπ Error stream stopped', 'info');
        }

        function updateStreamStatus(connected) {
            const dot = document.getElementById('streamStatusDot');
            const text = document.getElementById('streamStatusText');
            const startBtn = document.getElementById('startStreamBtn');
            const stopBtn = document.getElementById('stopStreamBtn');
            const indicator = document.getElementById('streamIndicator');
            
            if (connected) {
                dot.className = 'status-dot connected';
                text.textContent = 'Real-time error stream: Connected';
                indicator.textContent = 'LIVE';
                indicator.style.background = '#10b981';
                startBtn.style.display = 'none';
                stopBtn.style.display = 'inline-block';
            } else {
                dot.className = 'status-dot';
                text.textContent = 'Real-time error stream: Disconnected';
                indicator.textContent = 'OFFLINE';
                indicator.style.background = '#dc2626';
                startBtn.style.display = 'inline-block';
                stopBtn.style.display = 'none';
            }
        }

        async function showErrorDetails(errorId) {
            const error = currentErrorData.find(e => e.id === errorId);
            if (!error) {
                showMessage('Error details not found', 'error');
                return;
            }
            
            const modal = document.getElementById('errorDetailsModal');
            const content = document.getElementById('errorModalContent');
            
            const severity = error.severity?.toLowerCase() || 'info';
            const severityClass = `severity-${severity}`;
            
            content.innerHTML = `
                <div style="margin-bottom: 24px;">
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 20px;">
                        <div>
                            <h3 style="color: #e2e8f0; margin-bottom: 8px;">${error.error_type || 'Unknown Error'}</h3>
                            <span class="severity-badge ${severityClass}" style="font-size: 0.85rem;">
                                ${severity.toUpperCase()}
                            </span>
                        </div>
                        <div style="text-align: right;">
                            <div style="color: #94a3b8; font-size: 0.9rem;">Error ID</div>
                            <div style="font-family: monospace; color: #cbd5e1; font-size: 0.9rem;">${error.id || 'N/A'}</div>
                        </div>
                    </div>
                    
                    <div style="background: #0f172a; border-radius: 8px; padding: 16px; border: 1px solid #334155; margin-bottom: 16px;">
                        <div style="color: #94a3b8; font-size: 0.85rem; margin-bottom: 4px;">Timestamp</div>
                        <div style="color: #e2e8f0; font-family: monospace;">${new Date(error.timestamp).toLocaleString()}</div>
                    </div>
                    
                    <div style="background: #0f172a; border-radius: 8px; padding: 16px; border: 1px solid #334155; margin-bottom: 16px;">
                        <div style="color: #94a3b8; font-size: 0.85rem; margin-bottom: 4px;">User ID</div>
                        <div style="color: #60a5fa; font-family: monospace;">${error.user_id || 'unknown'}</div>
                    </div>
                    
                    <div style="background: #0f172a; border-radius: 8px; padding: 16px; border: 1px solid #334155; margin-bottom: 16px;">
                        <div style="color: #94a3b8; font-size: 0.85rem; margin-bottom: 4px;">Endpoint</div>
                        <div style="color: #a78bfa;">${error.endpoint || 'unknown'}</div>
                    </div>
                </div>
                
                <div style="margin-bottom: 24px;">
                    <h4 style="color: #e2e8f0; margin-bottom: 12px;">Error Message</h4>
                    <div class="code-block">${escapeHtml(error.error_message || 'No message')}</div>
                </div>
                
                ${error.extra_data ? `
                    <div style="margin-bottom: 24px;">
                        <h4 style="color: #e2e8f0; margin-bottom: 12px;">Additional Data</h4>
                        <pre class="code-block">${JSON.stringify(error.extra_data, null, 2)}</pre>
                    </div>
                ` : ''}
                
                <div style="display: flex; gap: 12px; justify-content: center; margin-top: 32px;">
                    <button class="btn btn-secondary" onclick="copyErrorDetails('${errorId}')">
                        üìã Copy Details
                    </button>
                    <button class="btn" onclick="closeErrorDetails()">
                        Close
                    </button>
                </div>
            `;
            
            modal.style.display = 'flex';
        }

        function closeErrorDetails() {
            document.getElementById('errorDetailsModal').style.display = 'none';
        }

        async function copyErrorDetails(errorId) {
            const error = currentErrorData.find(e => e.id === errorId);
            if (!error) return;
            
            const text = `Error Details:
ID: ${error.id}
Timestamp: ${new Date(error.timestamp).toLocaleString()}
User ID: ${error.user_id}
Endpoint: ${error.endpoint}
Error Type: ${error.error_type}
Severity: ${error.severity}
Message: ${error.error_message}
${error.extra_data ? `Extra Data: ${JSON.stringify(error.extra_data, null, 2)}` : ''}`;
            
            try {
                await navigator.clipboard.writeText(text);
                showMessage('‚úÖ Error details copied to clipboard', 'success');
            } catch (error) {
                console.error('Copy failed:', error);
                showMessage('‚ùå Failed to copy to clipboard', 'error');
            }
        }

        async function clearOldErrors() {
            const days = prompt('Clear errors older than how many days?', '30');
            if (days === null) return;
            
            try {
                // Clear from server if logged in
                if (currentSession) {
                    const response = await fetch(`${API_BASE_URL}/admin/errors/clear?days=${days}`, {
                        method: 'DELETE',
                        headers: {
                            'X-User-ID': currentSession.uid,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`Clear failed: ${response.status}`);
                    }
                }
                
                // Clear from local storage
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - days);
                
                const filteredErrors = currentErrorData.filter(error => 
                    new Date(error.timestamp) >= cutoffDate
                );
                
                if (filteredErrors.length < currentErrorData.length) {
                    currentErrorData = filteredErrors;
                    saveErrorsToStorage();
                    
                    // Update UI
                    updateErrorSummary(currentErrorData);
                    displayErrors(currentErrorData);
                    
                    showMessage(`‚úÖ Cleared errors older than ${days} days. ${currentErrorData.length} errors remain.`, 'success');
                } else {
                    showMessage(`No errors older than ${days} days found.`, 'info');
                }
                
            } catch (error) {
                console.error('Clear errors error:', error);
                showMessage('‚ùå Could not clear errors: ' + error.message, 'error');
            }
        }

        // ========== STATS FUNCTIONS ==========

        let lastRefreshTime = 0;
        const MIN_REFRESH_INTERVAL = 2000;

        async function refreshStats() {
            const now = Date.now();
            if (now - lastRefreshTime < MIN_REFRESH_INTERVAL) {
                console.log('‚è≥ Skipping refresh - too soon');
                return;
            }
    
            lastRefreshTime = now;
    
            if (!currentSession) {
                showMessage('Please log in first', 'error');
                return;
            }

            console.log('üîÑ Refreshing stats...');
    
            const refreshBtn = document.getElementById('refreshBtn');
            refreshBtn.classList.add('loading');
    
            const serverStatus = document.getElementById('serverStatus');
            serverStatus.textContent = '‚è≥ Loading...';

            try {
                const response = await fetch(`${API_BASE_URL}/stats`, {
                    headers: {
                        'X-User-ID': currentSession.uid,
                        'Content-Type': 'application/json'
                    }
                });
        
                console.log('üìä Stats response status:', response.status);
        
                if (!response.ok) {
                    if (response.status === 429) {
                        showMessage('‚ö†Ô∏è Rate limit reached. Please wait before refreshing again.', 'error');
                        return;
                    }
                    const errorText = await response.text();
                    console.error('‚ùå Stats error response:', errorText);
                    throw new Error(`Stats endpoint returned ${response.status}: ${errorText}`);
                }
        
                const data = await response.json();
                console.log('üìä Stats data received:', data);
        
                if (data.success) {
                    updateDashboard(data);
                    showMessage('‚úÖ Stats updated successfully', 'success');
                } else {
                    throw new Error('Stats endpoint returned unsuccessful response');
                }
            } catch (error) {
                console.error('‚ùå Stats error:', error);
        
                if (error.message.includes('429')) {
                    showMessage('‚ö†Ô∏è Rate limit exceeded. Please wait 60 seconds.', 'error');
                } else if (error.message.includes('500')) {
                    showMessage('‚ö†Ô∏è Server error - check server logs for details', 'error');
                } else if (error.message.includes('403')) {
                    showMessage('‚ùå Access denied - admin privileges required', 'error');
                } else if (error.message.includes('401')) {
                    showMessage('üîê Authentication failed - please log in again', 'error');
                } else {
                    showMessage('‚ö†Ô∏è Could not load comprehensive stats: ' + error.message, 'error');
                }
            } finally {
                refreshBtn.classList.remove('loading');
                checkServerHealth();
            }
        }

        function updateDashboard(stats) {
            console.log('üìä Updating dashboard with:', stats);
            
            if (stats.daily_stats) {
                const dailyStats = stats.daily_stats;
                
                const dailyCost = parseFloat(dailyStats.daily_cost || 0);
                const dailyCostElement = document.getElementById('dailyCost');
                dailyCostElement.textContent = `$${dailyCost.toFixed(6)}`;
                
                if (dailyCost > 1.0) {
                    dailyCostElement.className = 'stat-value cost-critical';
                } else if (dailyCost > 0.1) {
                    dailyCostElement.className = 'stat-value cost-warning';
                } else {
                    dailyCostElement.className = 'stat-value cost-good';
                }
                
                document.getElementById('dailyRequests').textContent = dailyStats.daily_requests || 0;
                document.getElementById('dailyTokens').textContent = (dailyStats.daily_tokens || 0).toLocaleString();
                document.getElementById('dailyAlignments').textContent = dailyStats.daily_alignments || 0;
                document.getElementById('costPerRequest').textContent = `$${(dailyStats.cost_per_request || 0).toFixed(6)}/req`;
                document.getElementById('tokensPerRequest').textContent = (dailyStats.tokens_per_request || 0).toFixed(1);
                
                const hits = dailyStats.daily_cache_hits || 0;
                const misses = dailyStats.daily_cache_misses || 0;
                const newUsersToday = stats.daily_stats.new_users_today ?? 0;
                const newUsersWeek = stats.daily_stats.new_users_week ?? 0;
                const newUsersMonth = stats.daily_stats.new_users_month ?? 0;
                const newUsersYear = stats.daily_stats.new_users_year ?? 0;
                const totalRequests = hits + misses;
                const hitRate = totalRequests > 0 ? (hits / totalRequests) * 100 : 0;
                const savings = hits * 0.02;
                
                document.getElementById('cacheHitRate').textContent = `${hitRate.toFixed(1)}%`;
                document.getElementById('cacheEfficiency').textContent = `${hitRate.toFixed(1)}%`;
                document.getElementById('cacheSavings').textContent = `$${savings.toFixed(2)}`;
                document.getElementById('cacheHitBar').style.width = `${hitRate}%`;
                document.getElementById('cacheHits').textContent = hits;
                document.getElementById('cacheMisses').textContent = misses;

                document.getElementById('totalUsers').textContent = dailyStats.user_count || 0;
                document.getElementById('newUsersToday').textContent = newUsersToday;
                document.getElementById('newUsersTodayDiv').textContent = newUsersToday;
                document.getElementById('newUsersWeekDiv').textContent = newUsersWeek;
                document.getElementById('newUsersMonthDiv').textContent = newUsersMonth;
                document.getElementById('newUsersYearDiv').textContent = newUsersYear;
                document.getElementById('emailVerifiedCount').textContent = dailyStats.email_verified_count || 0;
            }

            if (stats.jd_alignment_stats) {
                document.getElementById('totalAlignments').textContent = stats.jd_alignment_stats.total_alignments || 0;
                document.getElementById('avgImprovement').textContent = `+${(stats.jd_alignment_stats.average_improvement || 0).toFixed(3)}`;
                document.getElementById('avgFinalScore').textContent = (stats.jd_alignment_stats.average_final_score || 0).toFixed(3);
                document.getElementById('maxImprovement').textContent = `+${(stats.jd_alignment_stats.max_improvement || 0).toFixed(3)}`;
                
                updateRecentAlignments(stats.jd_alignment_stats.recent_alignments || []);
            }
            
            if (stats.cost_history && stats.cost_history.length > 0) {
                updateCostHistory(stats.cost_history);
            }
            
            if (stats.error_statistics) {
                const totalErrors = stats.error_statistics.total_errors || 0;
                const highErrors = stats.error_statistics.by_severity?.high || 0;
                document.getElementById('totalErrors').textContent = totalErrors;
                document.getElementById('highErrors').textContent = highErrors;
            }
            
            if (stats.user_analytics) {
                document.getElementById('totalUsersTracked').textContent = stats.user_analytics.total_users_tracked || 0;
                document.getElementById('activeUsersToday').textContent = stats.user_analytics.active_users_today || 0;
                document.getElementById('totalUserRequests').textContent = stats.user_analytics.total_requests_tracked || 0;
                
                if (stats.user_analytics.top_users && stats.user_analytics.top_users.length > 0) {
                    updateTopUsersList(stats.user_analytics.top_users);
                }
            }
            
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
            
            console.log('‚úÖ Dashboard update complete');
        }

        function updateRecentAlignments(alignments) {
            const container = document.getElementById('recentAlignments');
            
            if (!alignments || alignments.length === 0) {
                container.innerHTML = '<p style="color: #94a3b8; text-align: center; padding: 20px;">No recent alignments.</p>';
                return;
            }

            let html = '<table class="data-table">';
            html += '<thead><tr><th>Time</th><th>Initial Score</th><th>Final Score</th><th>Improvement</th><th>Keywords</th></tr></thead><tbody>';
            
            alignments.slice(0, 10).forEach(align => {
                const time = new Date(align.timestamp).toLocaleTimeString();
                const improvement = align.improvement || 0;
                const improvementPercent = align.improvement_percentage ? 
                    `${align.improvement_percentage.toFixed(1)}%` : 'N/A';
                
                html += `
                    <tr>
                        <td style="color: #94a3b8; font-size: 0.85rem;">${time}</td>
                        <td style="color: #cbd5e1;">${(align.initial_score || 0).toFixed(3)}</td>
                        <td style="color: #60a5fa; font-weight: 600;">${(align.final_score || 0).toFixed(3)}</td>
                        <td style="color: ${improvement > 0 ? '#34d399' : '#f87171'};">
                            +${improvement.toFixed(3)} (${improvementPercent})
                        </td>
                        <td style="text-align: center; color: #cbd5e1;">${align.keywords_found || 0}</td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function updateCostHistory(history) {
            const container = document.getElementById('costHistory');
            
            if (!history || history.length === 0) {
                container.innerHTML = '<p style="color: #94a3b8; text-align: center; padding: 20px;">No cost history available.</p>';
                return;
            }

            let html = '<table class="data-table">';
            html += '<thead><tr><th>Date</th><th>Cost</th><th>Tokens</th><th>Requests</th><th>Alignments</th></tr></thead><tbody>';
            
            const sortedHistory = [...history].sort((a, b) => 
                new Date(b.date || b.timestamp) - new Date(a.date || a.timestamp)
            ).slice(0, 30);
            
            sortedHistory.forEach(day => {
                const cost = day.daily_cost || day.cost || 0;
                const tokens = day.daily_tokens || 0;
                const requests = day.daily_requests || 0;
                const alignments = day.daily_alignments || 0;
                const date = day.date || new Date(day.timestamp).toLocaleDateString();
                
                html += `
                    <tr>
                        <td style="color: #94a3b8;">${date}</td>
                        <td style="color: ${cost > 1 ? '#f87171' : cost > 0.1 ? '#fbbf24' : '#34d399'}">
                            $${cost.toFixed(6)}
                        </td>
                        <td style="text-align: right; color: #cbd5e1;">${tokens.toLocaleString()}</td>
                        <td style="text-align: right; color: #cbd5e1;">${requests}</td>
                        <td style="text-align: right; color: #a78bfa;">${alignments}</td>
                    </tr>
                `;
            });
            
            const totalCost = sortedHistory.reduce((sum, day) => sum + (day.daily_cost || day.cost || 0), 0);
            const totalTokens = sortedHistory.reduce((sum, day) => sum + (day.daily_tokens || 0), 0);
            const totalRequests = sortedHistory.reduce((sum, day) => sum + (day.daily_requests || 0), 0);
            const totalAlignments = sortedHistory.reduce((sum, day) => sum + (day.daily_alignments || 0), 0);
            
            html += `
                <tr style="background: #0f172a;">
                    <td style="font-weight: 700; color: #e2e8f0;">Total</td>
                    <td style="font-weight: 700; color: #e2e8f0;">$${totalCost.toFixed(6)}</td>
                    <td style="text-align: right; font-weight: 700; color: #e2e8f0;">${totalTokens.toLocaleString()}</td>
                    <td style="text-align: right; font-weight: 700; color: #e2e8f0;">${totalRequests}</td>
                    <td style="text-align: right; font-weight: 700; color: #e2e8f0;">${totalAlignments}</td>
                </tr>
            `;
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function updateTopUsersList(users) {
            const container = document.getElementById('topUsersContent');
            
            if (!users || users.length === 0) {
                container.innerHTML = '<p style="color: #94a3b8; text-align: center; padding: 20px;">No user activity data available.</p>';
                return;
            }

            let html = '<table class="data-table">';
            html += '<thead><tr><th>User ID</th><th>Total Requests</th><th>Last Active</th></tr></thead><tbody>';
            
            users.slice(0, 10).forEach(user => {
                const shortUserId = user.user_id?.substring(0, 20) + (user.user_id?.length > 20 ? '...' : '');
                
                html += `
                    <tr>
                        <td>
                            <div class="tooltip">
                                <span style="font-family: monospace; color: #60a5fa;">${shortUserId}</span>
                                <span class="tooltip-text">${user.user_id}</span>
                            </div>
                        </td>
                        <td style="text-align: right; color: #cbd5e1;">${user.total_requests || 0}</td>
                        <td style="color: #94a3b8; font-size: 0.85rem;">
                            ${user.last_active ? new Date(user.last_active).toLocaleDateString() : 'Unknown'}
                        </td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function checkServerHealth() {
            fetch(`${API_BASE_URL}/health`)
                .then(response => {
                    if (!response.ok) throw new Error('Health check failed');
                    return response.json();
                })
                .then(health => {
                    const statusEl = document.getElementById('serverStatus');
                    if (statusEl) {
                        if (health.status === 'healthy') {
                            statusEl.textContent = '‚úÖ Online';
                            statusEl.style.color = '#34d399';
                        } else {
                            statusEl.textContent = '‚ö†Ô∏è Degraded';
                            statusEl.style.color = '#fbbf24';
                        }
                    }
                })
                .catch(() => {
                    const statusEl = document.getElementById('serverStatus');
                    if (statusEl) {
                        statusEl.textContent = '‚ùå Offline';
                        statusEl.style.color = '#f87171';
                    }
                });
        }

        async function resetDailyStats() {
            if (!confirm('‚ö†Ô∏è Are you sure you want to reset daily statistics?\n\nThis will:\n‚Ä¢ Save current stats to backup\n‚Ä¢ Reset all daily counters to zero\n‚Ä¢ This action cannot be undone!')) {
                return;
            }
            
            const resetBtn = document.getElementById('resetBtn');
            resetBtn.classList.add('loading');
            
            try {
                const response = await fetch(`${API_BASE_URL}/stats/reset-daily`, {
                    method: 'POST',
                    headers: {
                        'X-User-ID': currentSession.uid,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    showMessage('‚úÖ Daily statistics reset successfully', 'success');
                    refreshStats();
                } else {
                    throw new Error('Reset failed');
                }
                
            } catch (error) {
                console.error('Reset error:', error);
                showMessage('‚ùå Could not reset statistics: ' + error.message, 'error');
            } finally {
                resetBtn.classList.remove('loading');
            }
        }

        function exportData() {
            showMessage('üì§ Export feature would generate CSV reports', 'info');
        }

        function logout() {
            if (!confirm('Are you sure you want to logout?')) {
                return;
            }
            
            stopErrorStream();
            stopAutoRefresh();
            stopSessionTimer();
            
            currentSession = null;
            errorEventSource = null;
            isStreaming = false;
            
            localStorage.removeItem('admin_uid');
            
            showLoginScreen();
        }

        // ========== UTILITY FUNCTIONS ==========

        function showMessage(message, type = 'info') {
            const container = document.getElementById('messageContainer');
            if (!container) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message message-${type}`;
            messageDiv.innerHTML = `
                ${message}
                <button onclick="this.parentElement.remove()" 
                        style="float: right; background: none; border: none; color: #94a3b8; cursor: pointer; font-size: 18px;">
                    √ó
                </button>
            `;
            
            container.appendChild(messageDiv);
            
            setTimeout(() => {
                if (messageDiv.parentElement) {
                    messageDiv.remove();
                }
            }, 5000);
        }

        function startSessionTimer() {
            sessionTimerInterval = setInterval(() => {
                if (!sessionStartTime) return;
                
                const now = new Date();
                const diff = Math.floor((now - sessionStartTime) / 1000);
                const minutes = Math.floor(diff / 60);
                const seconds = diff % 60;
                
                document.getElementById('sessionTimer').textContent = 
                    `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        function stopSessionTimer() {
            if (sessionTimerInterval) {
                clearInterval(sessionTimerInterval);
                sessionTimerInterval = null;
            }
        }

        function startAutoRefresh() {
            if (autoRefreshEnabled) {
                refreshInterval = setInterval(refreshStats, 45000);
                document.getElementById('autoRefreshStatus').textContent = 'Auto-refresh: On';
            }
        }

        function stopAutoRefresh() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
                document.getElementById('autoRefreshStatus').textContent = 'Auto-refresh: Off';
            }
        }

        function toggleAutoRefresh() {
            autoRefreshEnabled = document.getElementById('autoRefreshToggle').checked;
            
            if (autoRefreshEnabled) {
                startAutoRefresh();
            } else {
                stopAutoRefresh();
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        document.addEventListener('keydown', function(event) {
            if (event.key === 'Enter' && event.target.tagName !== 'TEXTAREA') {
                event.preventDefault();
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            const timeFilter = document.getElementById('errorTimeFilter');
            if (timeFilter) {
                timeFilter.addEventListener('change', (e) => {
                    const value = e.target.value;
                    const days = value === 'all' ? 3650 : Number(value);
                    loadAllErrors(days);
                });
            }
        });

    </script>
</body>
</html>
